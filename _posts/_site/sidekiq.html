<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">异步任务的入队</a>    <ul>
      <li><a href="#redis-" id="markdown-toc-redis-">Redis 中的存储</a></li>
    </ul>
  </li>
  <li><a href="#sidekiq-" id="markdown-toc-sidekiq-">Sidekiq 的启动过程</a>    <ul>
      <li><a href="#launcher--manager" id="markdown-toc-launcher--manager">从 Launcher 到 Manager</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">并行模型</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">『主题』的订阅</a></li>
    </ul>
  </li>
  <li><a href="#section-4" id="markdown-toc-section-4">异步任务的处理</a>    <ul>
      <li><a href="#section-5" id="markdown-toc-section-5">定时任务</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">执行任务</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">小结</a></li>
    </ul>
  </li>
  <li><a href="#section-8" id="markdown-toc-section-8">中间件</a>    <ul>
      <li><a href="#section-9" id="markdown-toc-section-9">实现</a></li>
    </ul>
  </li>
  <li><a href="#section-10" id="markdown-toc-section-10">任务的重试</a></li>
  <li><a href="#section-11" id="markdown-toc-section-11">总结</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<p><a href="https://github.com/mperham/sidekiq">Sidekiq</a> 是 Ruby 和 Rails 项目中常用的后台任务处理系统，其本身提供的 API 十分简洁，源代码也非常易于阅读，是一个轻量级的异步处理组件；虽然其本身没有提供太多复杂的功能，但是它的使用和部署非常简单。在这篇文章中，我们将对 Sidekiq 的实现原理进行介绍和分析。</p>

<p><img src="http://img.draveness.me/2017-08-28-Sidekiq-Cover.jpg" alt="Sidekiq-Cover" /></p>

<p>文章中并不会详细介绍 Sidekiq 的使用，也并不是一篇 Sidekiq 的教程，在这里我们会介绍任务的入队过程、Sidekiq 任务在 Redis 中的存储方式和消费者对任务的处理过程，除此之外，文章将介绍 Sidekiq 中间件的实现以及任务重试的原理。</p>

<h2 id="section">概述</h2>

<p>在具体分析介绍 Sidekiq 的实现原理之前，我们需要对整个组件的使用过程进行概述，保证我们对 Sidekiq 的结构有一个总体上的了解。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HardWorker</span>
  <span class="kp">include</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Worker</span>
  <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
    <span class="c1"># do something</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">HardWorker</span><span class="p">.</span><span class="nf">perform_async</span><span class="p">(</span><span class="s1">'bob'</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
</div>

<p>在这里，我们直接照搬 Sidekiq Wiki 中 <a href="https://github.com/mperham/sidekiq/wiki/Getting-Started">Getting Started</a> 部分的代码简单展示下它是如何使用的，当我们执行 <code class="highlighter-rouge">HardWorker.perform_async</code> 方法时，Sidekiq 的 Worker 会将一个异步任务以 JSON 的形式将相关的信息加入 Redis 中并等待消费者对任务的拉取和处理。</p>

<p><img src="http://img.draveness.me/2017-08-28-Sidekiq-Arch.jpg" alt="Sidekiq-Arch" /></p>

<p>Sidekiq 的消费者有三个部分组成，分别是 <code class="highlighter-rouge">Manager</code>、<code class="highlighter-rouge">Processor</code> 和 <code class="highlighter-rouge">Poller</code>；他们三者会相互协作共同完成对 Redis 中任务消费的过程。</p>

<blockquote>
  <p>需要注意的是，Sidekiq 中的 <code class="highlighter-rouge">Sidekiq::Worker</code> 并不是真正用于处理任务的 Worker，负责执行执行任务的类型其实是 <code class="highlighter-rouge">Sidekiq::Processor</code>；在文章中，当我们提到 Sidekiq Worker 时，其实说的是 <code class="highlighter-rouge">Sidekiq::Processor</code>，当我们使用了形如 <code class="highlighter-rouge">Sidekiq::Worker</code> 或者 <code class="highlighter-rouge">Worker</code> 的形式时，我们说的就是对应的类。</p>
</blockquote>

<h2 id="section-1">异步任务的入队</h2>

<p>当我们对需要异步执行的任务调用类似 <code class="highlighter-rouge">Worker.perform_async</code> 的方法时，Sidekiq 其实并不会真正去创建一个 <code class="highlighter-rouge">HardWorker</code> 等 <code class="highlighter-rouge">Worker</code> 的对象，它实际上会调用 <code class="highlighter-rouge">Worker.client_push</code> 方法并将当前的 <code class="highlighter-rouge">class</code> 和 <code class="highlighter-rouge">args</code> 参数传进去，也就是需要异步执行的类和参数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_async</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">client_push</span><span class="p">(</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="p">,</span> <span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">args</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>除了 <code class="highlighter-rouge">Worker.perform_async</code> 之外，<code class="highlighter-rouge">Worker</code> 还提供了另外一对用于<strong>在一段时间之后或者某个时间点</strong>执行相应任务的方法 <code class="highlighter-rouge">Worker.perform_at</code> 和 <code class="highlighter-rouge">Worker.perform_in</code>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_in</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">int</span> <span class="o">=</span> <span class="n">interval</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="n">now</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="p">(</span><span class="n">int</span> <span class="o">&lt;</span> <span class="mi">1_000_000_000</span> <span class="p">?</span> <span class="n">now</span> <span class="o">+</span> <span class="n">int</span> <span class="p">:</span> <span class="n">int</span><span class="p">)</span>
  <span class="n">item</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="p">,</span> <span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">args</span><span class="p">,</span> <span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">ts</span> <span class="p">}</span>
  <span class="n">item</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">)</span> <span class="k">if</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">now</span>
  <span class="n">client_push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="k">end</span>
<span class="kp">alias_method</span> <span class="ss">:perform_at</span><span class="p">,</span> <span class="ss">:perform_in</span>
</code></pre>
</div>

<p>为了使用同一个接口支持两种不同的安排方式（时间点和多久之后），方法内部对传入的 <code class="highlighter-rouge">internal</code> 进行了判断，当 <code class="highlighter-rouge">interval.to_f &lt; 1_000_000_000</code> 时就会在一段时间之后执行任务，否则就会以时间点的方式执行任务，虽然 <code class="highlighter-rouge">Worker.perform_at</code> 和 <code class="highlighter-rouge">Worker.perform_in</code> 是完全相同的方法，不过我们在使用时还是尽量遵循方法的语义选择两者中更符合逻辑的方法。</p>

<p><img src="http://img.draveness.me/2017-08-28-Client-Push-Item.jpg" alt="Client-Push-Item" /></p>

<p>两种创建异步任务的方式，最终都执行了 <code class="highlighter-rouge">Worker.client_push</code> 方法并传入了一个哈希，其中可能包含以上三个部分的内容；在方法的实现中，它获取了上下文中的 Redis 池并将传入的 <code class="highlighter-rouge">item</code> 对象传入 Redis 中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">client_push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">pool</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="ss">:sidekiq_via_pool</span><span class="p">]</span> <span class="o">||</span> <span class="n">get_sidekiq_options</span><span class="p">[</span><span class="s1">'pool'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">||</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis_pool</span>
  <span class="n">item</span><span class="p">.</span><span class="nf">keys</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
    <span class="n">item</span><span class="p">[</span><span class="n">key</span><span class="p">.</span><span class="nf">to_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">pool</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>简单整理一下，从 <code class="highlighter-rouge">Worker.perform_async</code> 方法到 <code class="highlighter-rouge">Client#push</code> 方法整个过程都在对即将加入到 Redis 中队列的哈希进行操作，从添加 <code class="highlighter-rouge">at</code> 字段到字符串化、再到 <code class="highlighter-rouge">Client#normalize_item</code> 方法中添加 <code class="highlighter-rouge">jid</code> 和 <code class="highlighter-rouge">created_at</code> 字段。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">normed</span> <span class="o">=</span> <span class="n">normalize_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">payload</span> <span class="o">=</span> <span class="n">process_single</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">],</span> <span class="n">normed</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">payload</span>
    <span class="n">raw_push</span><span class="p">([</span><span class="n">payload</span><span class="p">])</span>
    <span class="n">payload</span><span class="p">[</span><span class="s1">'jid'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>所有添加异步任务的方法最终都调用了私有方法 <code class="highlighter-rouge">Client#raw_push</code> 以及 <code class="highlighter-rouge">Client#atomic_push</code> 向 Redis 中添加数据，在这时会有两种不同的情况发生，当异步任务需要在未来的某一时间点进行安排时，它会加入 Redis 的一个有序集合：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">atomc_push</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">payloads</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">zadd</span><span class="p">(</span><span class="s1">'schedule'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="nb">hash</span><span class="o">|</span>
                <span class="n">at</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">).</span><span class="nf">to_s</span>
                <span class="p">[</span><span class="n">at</span><span class="p">,</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="nb">hash</span><span class="p">)]</span>
              <span class="k">end</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>在这个有序集合中，Sidekiq 理所应当地将 <code class="highlighter-rouge">schedule</code> 作为权重，而其他的全部字段都以 JSON 的格式作为负载传入；但是当 Sidekiq 遇到需要立即执行的异步任务时，实现就有一些不同了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">atomc_push</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">payloads</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="c1"># ...</span>
  <span class="k">else</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="n">now</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
    <span class="n">to_push</span> <span class="o">=</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">entry</span><span class="o">|</span>
      <span class="n">entry</span><span class="p">[</span><span class="s1">'enqueued_at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span>
      <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">sadd</span><span class="p">(</span><span class="s1">'queues'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">lpush</span><span class="p">(</span><span class="s2">"queue:</span><span class="si">#{</span><span class="n">q</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">to_push</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>除了设置当前任务的入队时间 <code class="highlighter-rouge">enqueued_at</code> 之外，Sidekiq 将队列加入到一个大队列 <code class="highlighter-rouge">queues</code> 的集合中，并且将负载直接推到 <code class="highlighter-rouge">"queue:#{q}"</code> 数组中等待消费者的拉取，我们稍微梳理一下两种安排异步队列方法的调用过程：</p>

<p><img src="http://img.draveness.me/2017-08-28-Async-Schedule.jpg" alt="Async-Schedule" /></p>

<h3 id="redis-">Redis 中的存储</h3>

<p>无论是立即执行还是需要安排的异步任务都会进入 Redis 的队列中，但是它们之间还是有一些区别的，<code class="highlighter-rouge">Worker.perform_in/at</code> 会将任务以 <code class="highlighter-rouge">[at, args]</code> 的形式加入到 <code class="highlighter-rouge">schedules</code> 有序集中，而
<code class="highlighter-rouge">Worker.perform_async</code> 将负载加入到指定的队列，并向整个 Sidekiq 的队列集合 <code class="highlighter-rouge">queues</code> 中添加该队列。</p>

<p><img src="http://img.draveness.me/2017-08-28-Perform-async-in-Redis.jpg" alt="Perform-async-in-Redis" /></p>

<p>所有的 <code class="highlighter-rouge">payload</code> 中都包含了一个异步任务需要执行的全部信息，包括该任务的执行的队列 <code class="highlighter-rouge">queue</code>、异步队列的类 <code class="highlighter-rouge">class</code>、参数 <code class="highlighter-rouge">args</code> 以及 <code class="highlighter-rouge">sidekiq_options</code> 中的全部参数。</p>

<p><img src="http://img.draveness.me/2017-08-28-Job-in-Redis.jpg" alt="Job-in-Redis" /></p>

<p>除了上述参数，一个异步任务还包含诸如 <code class="highlighter-rouge">created_at</code>、<code class="highlighter-rouge">enqueued_at</code> 等信息，也有一个通过 <code class="highlighter-rouge">SecureRandom.hex(12)</code> 生成的任务唯一标识符 <code class="highlighter-rouge">jid</code>。</p>

<h2 id="sidekiq-">Sidekiq 的启动过程</h2>

<p>作者对于 Sidekiq 印象最深刻的就是它在命令行启动的时候输出的一个字符画，我们能在 <code class="highlighter-rouge">cli.rb</code> 的 <code class="highlighter-rouge">Cli.banner</code> 方法中找到这个字符画：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>         m,
         `$b
    .ss,  $$:         .,d$
    `$$P,d$P'    .,md$P"'
     ,$$$$$bmmd$$$P^'
   .d$$$$$$$$$$P'
   $$^' `"^$$$'       ____  _     _      _    _
   $:     ,$$:       / ___|(_) __| | ___| | _(_) __ _
   `b     :$$        \___ \| |/ _` |/ _ \ |/ / |/ _` |
          $$:         ___) | | (_| |  __/   &lt;| | (_| |
          $$         |____/|_|\__,_|\___|_|\_\_|\__, |
        .d$$                                       |_|
</code></pre>
</div>

<p>这一节也将介绍 Sidekiq 的启动过程，在 <code class="highlighter-rouge">bin</code> 文件夹中的 sidekiq 文件包含的内容就是在命令行执行 <code class="highlighter-rouge">sidekiq</code> 时执行的代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">begin</span>
  <span class="n">cli</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">CLI</span><span class="p">.</span><span class="nf">instance</span>
  <span class="n">cli</span><span class="p">.</span><span class="nf">parse</span>
  <span class="n">cli</span><span class="p">.</span><span class="nf">run</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>这里的代码就是创建了一个 <code class="highlighter-rouge">CLI</code> 对象，执行 <code class="highlighter-rouge">CLI#parse</code> 方法对参数进行解析，最后调用 <code class="highlighter-rouge">CLI#run</code> 方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="n">print_banner</span>

  <span class="n">self_read</span><span class="p">,</span> <span class="n">self_write</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
  <span class="c1"># ...</span>

  <span class="n">launcher</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Launcher</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="k">begin</span>
    <span class="n">launcher</span><span class="p">.</span><span class="nf">run</span>
    <span class="k">while</span> <span class="n">readable_io</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">self_read</span><span class="p">])</span>
      <span class="n">signal</span> <span class="o">=</span> <span class="n">readable_io</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">gets</span><span class="p">.</span><span class="nf">strip</span>
      <span class="n">handle_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Interrupt</span>
    <span class="n">launcher</span><span class="p">.</span><span class="nf">stop</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<h3 id="launcher--manager">从 Launcher 到 Manager</h3>

<p><code class="highlighter-rouge">CLI#run</code> 在执行最开始就会打印 banner，也就是我们在每次启动 Sidekiq 时看到的字符画，而在之后会执行 <code class="highlighter-rouge">Launcher#run</code> 运行用于处理异步任务的 <code class="highlighter-rouge">Processor</code> 等对象。</p>

<p><img src="http://img.draveness.me/2017-08-28-Launcher-Poller-Manager-Processors.jpg" alt="Launcher-Poller-Manager-Processors" /></p>

<p>每一个 <code class="highlighter-rouge">Launcher</code> 都会启动一个 <code class="highlighter-rouge">Manager</code> 对象和一个 <code class="highlighter-rouge">Poller</code>，其中 <code class="highlighter-rouge">Manager</code> 同时管理了多个 <code class="highlighter-rouge">Processor</code> 对象，这些不同的类之间有着如上图所示的关系。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="vi">@thread</span> <span class="o">=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"heartbeat"</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:start_heartbeat</span><span class="p">))</span>
  <span class="vi">@poller</span><span class="p">.</span><span class="nf">start</span>
  <span class="vi">@manager</span><span class="p">.</span><span class="nf">start</span>
<span class="k">end</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Manager</code> 会在初始化时根据传入的 <code class="highlighter-rouge">concurrency</code> 的值创建对应数量的 <code class="highlighter-rouge">Processor</code>，默认的并行数量为 25；当执行 <code class="highlighter-rouge">Manager#start</code> 时，就会启动对应数量的<strong>线程</strong>和处理器开始对任务进行处理：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Manager</span>
  <span class="k">def</span> <span class="nf">start</span>
    <span class="vi">@workers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
      <span class="n">x</span><span class="p">.</span><span class="nf">start</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Processor</span>
  <span class="k">def</span> <span class="nf">start</span>
    <span class="vi">@thread</span> <span class="o">||=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"processor"</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:run</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>从 <code class="highlighter-rouge">Launcher</code> 的启动到现在只是一个调用 <code class="highlighter-rouge">initialize</code> 和 <code class="highlighter-rouge">start</code> 方法的过程，再加上 Sidekiq 源代码非常简单，所以阅读起没有丝毫的难度，也就不做太多的解释了。</p>

<h3 id="section-2">并行模型</h3>

<p>当处理器开始执行 <code class="highlighter-rouge">Processor#run</code> 方法时，就开始对所有的任务进行处理了；从总体来看，Sidekiq 使用了多线程的模型对任务进行处理，每一个 <code class="highlighter-rouge">Processor</code> 都是使用了 <code class="highlighter-rouge">safe_thread</code> 方法在一个新的线程里面运行的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">safe_thread</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="s1">'sidekiq_label'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="n">watchdog</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>在使用 Sidekiq 时，我们也会在不同的机器上开启多个 Sidekiq Worker，也就是说 Sidekiq 可以以多进程、多线程的方式运行，同时处理大量的异步任务。</p>

<p><img src="http://img.draveness.me/2017-08-28-Sidekiq-Multi-Processes.jpg" alt="Sidekiq-Multi-Processes" /></p>

<p>到目前为止，我们已经分析了异步任务的入队以及 Sidekiq Worker 的启动过程了，接下来即将分析 Sidekiq 对异步任务的处理过程。</p>

<h3 id="section-3">『主题』的订阅</h3>

<p>作为一个 Sidekiq Worker 进程，它在启动时就会决定选择订阅哪些『主题』去执行，比如当我们使用下面的命令时：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">&gt; </span>sidekiq -q critical,2 -q default
</code></pre>
</div>

<p><code class="highlighter-rouge">CLI#parse</code> 方法会对传入的 <code class="highlighter-rouge">-q</code> 参数进行解析，但是当执行 <code class="highlighter-rouge">sidekiq</code> 命令却没有传入队列参数时，Sidekiq 只会订阅 <code class="highlighter-rouge">default</code> 队列中的任务：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="no">ARGV</span><span class="p">)</span>
  <span class="c1"># ...</span>
  <span class="n">validate!</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">validate!</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:queues</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s1">'default'</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:queues</span><span class="p">].</span><span class="nf">empty?</span>
<span class="k">end</span>
</code></pre>
</div>

<p>同时，默认情况下的队列的优先级都为 <code class="highlighter-rouge">1</code>，高优先级的队列在当前的任务中可以得到更多的执行机会，实现的方法是通过增加同一个 <code class="highlighter-rouge">queues</code> 集合中高优先级队列的数量，我们可以在 <code class="highlighter-rouge">CLI#parse_queue</code> 中找到实现这一功能的代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_queue</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
  <span class="p">[</span><span class="n">weight</span><span class="p">.</span><span class="nf">to_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">max</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="ss">:queues</span><span class="p">]</span> <span class="o">||=</span> <span class="p">[])</span> <span class="o">&lt;&lt;</span> <span class="n">q</span>
  <span class="k">end</span>
  <span class="n">opts</span><span class="p">[</span><span class="ss">:strict</span><span class="p">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">weight</span><span class="p">.</span><span class="nf">to_i</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre>
</div>

<p>到这里，其实我们就完成了设置过程中 Sidekiq Worker 『主题』订阅的功能了，我们将在后面 <a href="#执行任务">执行任务</a> 的部分具体介绍 Sidekiq 是如何使用这些参数的。</p>

<h2 id="section-4">异步任务的处理</h2>

<p>从异步任务的入队一节中，我们可以清楚地看到使用 <code class="highlighter-rouge">#perform_async</code> 和 <code class="highlighter-rouge">#perform_in</code> 两种方法创建的数据结构 <code class="highlighter-rouge">payload</code> 最终以不同的方式进入了 Redis 中，所以在这里我们将异步任务的处理分为定时任务和『立即』任务两个部分，分别对它们不同的处理方式进行分析。</p>

<h3 id="section-5">定时任务</h3>

<p>Sidekiq 使用 <code class="highlighter-rouge">Scheduled::Poller</code> 对 Redis 中 <code class="highlighter-rouge">schedules</code> 有序集合中的负载进行处理，其中包括 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 两个有序集合中的内容。</p>

<p><img src="http://img.draveness.me/2017-08-28-Redis-Sorted-Set.jpg" alt="Redis-Sorted-Set" /></p>

<p>在 <code class="highlighter-rouge">Poller</code> 被 <code class="highlighter-rouge">Scheduled::Poller</code> 启动时会调用 <code class="highlighter-rouge">#start</code> 方法开始对上述两个有序集合轮训，<code class="highlighter-rouge">retry</code> 中包含了所有重试的任务，而 <code class="highlighter-rouge">schedule</code> 就是被安排到指定时间执行的定时任务了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">start</span>
  <span class="vi">@thread</span> <span class="o">||=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"scheduler"</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">initial_wait</span>
    <span class="k">while</span> <span class="o">!</span><span class="vi">@done</span>
      <span class="n">enqueue</span>
      <span class="n">wait</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Scheduled::Poller#start</code> 方法内部执行了一个 <code class="highlighter-rouge">while</code> 循环，在循环内部也只包含入队和等待两个操作，用于入队的方法最终调用了 <code class="highlighter-rouge">Scheduled::Poll::Enq#enqueue_jobs</code> 方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">enqueue_jobs</span><span class="p">(</span><span class="n">now</span><span class="o">=</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">sorted_sets</span><span class="o">=</span><span class="no">SETS</span><span class="p">)</span>
  <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
    <span class="n">sorted_sets</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">sorted_set</span><span class="o">|</span>
      <span class="k">while</span> <span class="n">job</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">zrangebyscore</span><span class="p">(</span><span class="n">sorted_set</span><span class="p">,</span> <span class="s1">'-inf'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="ss">:limit</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]).</span><span class="nf">first</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">conn</span><span class="p">.</span><span class="nf">zrem</span><span class="p">(</span><span class="n">sorted_set</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
          <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">job</span><span class="p">))</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>传入的 <code class="highlighter-rouge">SETS</code> 其实就是 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 构成的数组，在上述方法中，Sidekiq 通过一个 <code class="highlighter-rouge">Redis#zrangebyscore</code> 和 <code class="highlighter-rouge">Redis#zrem</code> 将集合中小于当前时间的任务全部加到立即任务中，最终调用是在前面已经提到过的 <code class="highlighter-rouge">Client#push</code> 方法将任务推到指定的队列中。</p>

<p><img src="http://img.draveness.me/2017-08-28-Redis-Sidekiq-Poller.jpg" alt="Redis-Sidekiq-Poller" /></p>

<p>由于 <code class="highlighter-rouge">Scheduled::Poller</code> 并不是不停地对 Redis 中的数据进行处理的，因为当前进程一直都在执行 <code class="highlighter-rouge">Poller#enqueue</code> 其实是一个非常低效的方式，所以 Sidekiq 会在每次执行 <code class="highlighter-rouge">Poller#enqueue</code> 之后，执行 <code class="highlighter-rouge">Poller#wait</code> 方法，随机等待一段时间：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wait</span>
  <span class="vi">@sleeper</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="n">random_poll_interval</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">random_poll_interval</span>
  <span class="n">poll_interval_average</span> <span class="o">*</span> <span class="nb">rand</span> <span class="o">+</span> <span class="n">poll_interval_average</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="mi">2</span>
<span class="k">end</span>
</code></pre>
</div>

<p>随机等待时间的范围在 <code class="highlighter-rouge">[0.5 * poll_interval_average, 1.5 * poll_interval_average]</code> 之间；通过随机的方式，Sidekiq 可以避免在多个线程处理任务时，短时间内 Redis 接受大量的请求发生延迟等问题，能够保证从长期来看 Redis 接受的请求数是平均的；同时因为 <code class="highlighter-rouge">Scheduled::Poller</code> 使用了 <code class="highlighter-rouge">#enqueue</code> 加 <code class="highlighter-rouge">#wait</code> 对 Redis 中的数据进行消费，所以没有办法保证任务会在指定的时间点执行，<strong>执行的时间一定比安排的时间要晚</strong>，这也是我们在使用 Sidekiq 时需要注意的。</p>

<blockquote>
  <p>随机等待的时间其实不止与 <code class="highlighter-rouge">poll_interval_average</code> 有关，在默认情况下，它是当前进程数的 15 倍，在有 30 个 Sidekiq 线程时，每个线程会每隔 225 ~ 675s 的时间请求一次。</p>
</blockquote>

<h3 id="section-6">执行任务</h3>

<p>定时任务是由 <code class="highlighter-rouge">Scheduled::Poller</code> 进行处理的，将其中需要执行的异步任务加入到指定的队列中，而这些任务最终都会在 <code class="highlighter-rouge">Processor#run</code> 真正被执行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="k">begin</span>
    <span class="k">while</span> <span class="o">!</span><span class="vi">@done</span>
      <span class="n">process_one</span>
    <span class="k">end</span>
    <span class="vi">@mgr</span><span class="p">.</span><span class="nf">processor_stopped</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>当处理结束或者发生异常时会调用 <code class="highlighter-rouge">Manager#processor_stopped</code> 或者 <code class="highlighter-rouge">Manager#processor_died</code> 方法对 <code class="highlighter-rouge">Processor</code> 进行处理；在处理任务时其实也分为两个部分，也就是 <code class="highlighter-rouge">#fetch</code> 和 <code class="highlighter-rouge">#process</code> 两个方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_one</span>
  <span class="vi">@job</span> <span class="o">=</span> <span class="n">fetch</span>
  <span class="n">process</span><span class="p">(</span><span class="vi">@job</span><span class="p">)</span> <span class="k">if</span> <span class="vi">@job</span>
  <span class="vi">@job</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre>
</div>

<p>我们先来看一下整个方法的调用栈，任务的获取从 <code class="highlighter-rouge">Processor#process_one</code> 一路调用下来，直到 <code class="highlighter-rouge">BasicFetch#retrive_work</code> 返回了 <code class="highlighter-rouge">UnitOfWork</code> 对象，返回的对象会经过分发最后执行对应类的 <code class="highlighter-rouge">#perform</code> 传入参数真正运行该任务：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Processor#process_one
├── Processor#fetch
│   └── Processor#get_one
│       └── BasicFetch#retrive_work
│           ├── Redis#brpop
│           └── UnitOfWork#new
└── Processor#process
    ├── Processor#dispatch
    ├── Processor#execute_job
    └── Worker#perform
</code></pre>
</div>

<p>对于任务的获取，我们需要关注的就是 <code class="highlighter-rouge">BasicFetch#retrive_work</code> 方法，他会从 Redis 中相应队列的有序数组中 <code class="highlighter-rouge">Redis#brpop</code> 出一个任务，然后封装成 <code class="highlighter-rouge">UnitOfWork</code> 对象后返回。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retrieve_work</span>
  <span class="n">work</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="p">{</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span> <span class="n">conn</span><span class="p">.</span><span class="nf">brpop</span><span class="p">(</span><span class="o">*</span><span class="n">queues_cmd</span><span class="p">)</span> <span class="p">}</span>
  <span class="no">UnitOfWork</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="k">if</span> <span class="n">work</span>
<span class="k">end</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">#queues_cmd</code> 这个实例方法其实就用到了在主题的订阅一节中的 <code class="highlighter-rouge">queues</code> 参数，该参数会在 <code class="highlighter-rouge">Processor</code> 初始化是创建一个 <code class="highlighter-rouge">BasicFetch</code> 策略对象，最终在 <code class="highlighter-rouge">BasicFetch#queues_cmd</code> 方法调用时返回一个类似下面的数组：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:low</span>
<span class="n">queue</span><span class="ss">:low</span>
<span class="n">queue</span><span class="ss">:default</span>
</code></pre>
</div>

<p>这样就可以实现了队列的优先级这一个功能了，返回的 <code class="highlighter-rouge">UnitOfWork</code> 其实是一个通过 <code class="highlighter-rouge">Struct.new</code> 创建的结构体，它会在 <code class="highlighter-rouge">Processor#process</code> 方法中作为资源被处理：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="n">jobstr</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">job</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">queue_name</span>

  <span class="k">begin</span>
    <span class="c1"># ...</span>

    <span class="n">job_hash</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">jobstr</span><span class="p">)</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">worker</span><span class="o">|</span>
      <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">server_middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
        <span class="n">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>该方法对任务的执行其实总共有四个步骤：</p>

<ol>
  <li>将 Redis 中存储的字符串加载为 JSON；</li>
  <li>执行 <code class="highlighter-rouge">Processor#dispatch</code> 方法并在内部提供方法重试等功能，同时也实例化一个 <code class="highlighter-rouge">Sidekiq::Worker</code> 对象；</li>
  <li>依次执行服务端的中间件，可能会对参数进行更新；</li>
  <li>调用 <code class="highlighter-rouge">Processor#execute_job</code> 方法执行任务；</li>
</ol>

<p>而最后调用的时用于执行任务的方法 <code class="highlighter-rouge">Processor#execute_job</code>，它的实现也是到目前为止最为简单的方法之一了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned_args</span><span class="p">)</span>
  <span class="n">worker</span><span class="p">.</span><span class="nf">perform</span><span class="p">(</span><span class="o">*</span><span class="n">cloned_args</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>该方法在<strong>线程</strong>中执行了客户端创建的 <code class="highlighter-rouge">Worker</code> 类的实例方法 <code class="highlighter-rouge">#perform</code> 并传入了经过两侧中间件处理后的参数。</p>

<h3 id="section-7">小结</h3>

<p>到目前为止，Sidekiq Worker 对任务的消费过程就是圆满的了，从客户端创建一个拥有 <code class="highlighter-rouge">#perform</code> 方法的 <code class="highlighter-rouge">Worker</code> 到消费者去执行该方法形成了一个闭环，完成了对任务的调度。</p>

<p><img src="http://img.draveness.me/2017-08-28-Client-Redis-Sidekiq-Worker.jpg" alt="Client-Redis-Sidekiq-Worker" /></p>

<p>Sidekiq 是一个非常轻量级的任务调度系统，它使用 Redis 作为整个系统的消息队列，在两侧分别建立了生产者和消费者的模块，不过除了这几个比较重要的模块，Sidekiq 中还有一些功能是我们无法忽略的，比如中间件、兼容 ActiveJob 甚至是测试的实现，都是我们需要去了解的；接下来，我们将介绍和分析主干之外的『分叉』功能。</p>

<h2 id="section-8">中间件</h2>

<p>中间件模块是 Sidekiq 为我们在整个任务的处理流程提供的两个钩子，一个是在客户端的钩子，另一个在 Sidekiq Worker 中。</p>

<p><img src="http://img.draveness.me/2017-08-28-Middlewares-Client-Redis-Sidekiq-Worker.jpg" alt="Middlewares-Client-Redis-Sidekiq-Worker" /></p>

<p>中间件的使用其实非常简单，我们默认所有的中间件都会拥有一个实例方法 <code class="highlighter-rouge">#call</code> 并接受 <code class="highlighter-rouge">worker</code>、<code class="highlighter-rouge">job</code> 和 <code class="highlighter-rouge">queue</code> 三个参数，在使用时也只需要直接调用 <code class="highlighter-rouge">Chain#add</code> 方法将其加入数组就可以了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AcmeCo</span><span class="o">::</span><span class="no">MyMiddleware</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># config/initializers/sidekiq.rb</span>
<span class="no">Sidekiq</span><span class="p">.</span><span class="nf">configure_server</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">server_middleware</span> <span class="k">do</span> <span class="o">|</span><span class="n">chain</span><span class="o">|</span>
    <span class="n">chain</span><span class="p">.</span><span class="nf">add</span> <span class="no">AcmeCo</span><span class="o">::</span><span class="no">MyMiddleware</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Sidekiq 将中间件分为了客户端和服务端两个部分，这两个部分的中间件其实并不是严格意义上的在执行之前，由于执行时间点的不同，导致它们有不同的功能：</p>

<ul>
  <li>服务端中间件是『包围』了任务执行过程的，我们可以在中间件中使用 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 语句，这样当任务出现问题时，我们就可以拿到异常了；</li>
  <li>客户端中间件在任务即将被推入 Redis 之前运行，它能够阻止任务进入 Redis 并且允许我们在任务入队前对其进行修改和停止；</li>
</ul>

<p>当我们对 Sidekiq 中间的使用都有一定的了解时，就可以开始分析中间件的实现了。</p>

<h3 id="section-9">实现</h3>

<p>无论是异步任务真正进入队列之前，还是在客户端处理，跟任务有关的信息都会先通过一个预处理流程，客户端和服务端两个中间件的链式调用都使用 <code class="highlighter-rouge">Middleware::Chain</code> 中的类进行处理的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Chain</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>
  <span class="kp">attr_reader</span> <span class="ss">:entries</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@entries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">yield</span> <span class="nb">self</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">insert_before</span><span class="p">(</span><span class="n">oldklass</span><span class="p">,</span> <span class="n">newklass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">insert_after</span><span class="p">(</span><span class="n">oldklass</span><span class="p">,</span> <span class="n">newklass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>每一个 <code class="highlighter-rouge">Middleware::Chain</code> 中都包含一系列的 <code class="highlighter-rouge">Entry</code>，其中存储了中间件的相关信息，无论是客户端还是服务端都会在执行之前对每一个异步任务的参数执行 <code class="highlighter-rouge">invoke</code> 方法调用 <code class="highlighter-rouge">Middleware::Chain</code> 对象中的所有中间件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">chain</span> <span class="o">=</span> <span class="n">retrieve</span><span class="p">.</span><span class="nf">dup</span>
  <span class="n">traverse_chain</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">chain</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="k">yield</span>
    <span class="k">else</span>
      <span class="n">chain</span><span class="p">.</span><span class="nf">shift</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">traverse_chain</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">traverse_chain</span><span class="p">.</span><span class="nf">call</span>
<span class="k">end</span>

</code></pre>
</div>

<p><code class="highlighter-rouge">Chain#invoke</code> 会对其持有的每一个中间件都执行 <code class="highlighter-rouge">#call</code> 方法，中间件都可以对异步任务的参数进行改变或者进行一些记录日志等操作，最后执行传入的 block 并返回结果。</p>

<p><img src="http://img.draveness.me/2017-08-28-Sidekiq-Middlewares.jpg" alt="Sidekiq-Middlewares" /></p>

<p>当异步队列入队时，就会执行 <code class="highlighter-rouge">Client#process_single</code> 方法调用 Sidekiq 载入中的全部中间件最后返回新的 <code class="highlighter-rouge">item</code> 对象：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_single</span><span class="p">(</span><span class="n">worker_class</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="n">middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker_class</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="vi">@redis_pool</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">item</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>每一个 Sidekiq Worker 在处理中间件时也基本遵循相同的逻辑，如 <code class="highlighter-rouge">#process</code> 方法先先执行各种中间件，最后再运行 block 中的内容。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="n">jobstr</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">job</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">queue_name</span>

  <span class="k">begin</span>
    <span class="c1"># ...</span>

    <span class="n">job_hash</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">jobstr</span><span class="p">)</span>
    <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">server_middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]))</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>在 <code class="highlighter-rouge">#execute_job</code> 方法执行期间，由于异步任务可能抛出异常，在这时，我们注册的中间件就可以根据情况对异常进行捕获并选择是否对异常进行处理或者抛给上层了。</p>

<h2 id="section-10">任务的重试</h2>

<p>Sidekiq 中任务的重试是由 <code class="highlighter-rouge">JobRetry</code> 负责的，<code class="highlighter-rouge">Prcessor</code> 中的 <code class="highlighter-rouge">#dispatch</code> 方法中调用了 <code class="highlighter-rouge">JobRetry#global</code> 方法捕获在异步任务执行过程中发生的错误：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
  <span class="n">pristine</span> <span class="o">=</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">)</span>

  <span class="c1"># ...</span>
  <span class="vi">@retrier</span><span class="p">.</span><span class="nf">global</span><span class="p">(</span><span class="n">pristine</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">klass</span>  <span class="o">=</span> <span class="n">constantize</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">])</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span>
    <span class="n">worker</span><span class="p">.</span><span class="nf">jid</span> <span class="o">=</span> <span class="n">job_hash</span><span class="p">[</span><span class="s1">'jid'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="vi">@retrier</span><span class="p">.</span><span class="nf">local</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">pristine</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
      <span class="k">yield</span> <span class="n">worker</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>任务的执行过程分别调用了两个 <code class="highlighter-rouge">JobRetry</code> 的方法 <code class="highlighter-rouge">#global</code> 和 <code class="highlighter-rouge">#local</code>，这两个方法在实现上差不多，都将执行异步任务的 block 包在了一个 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 中，选择在合适的时间重试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">local</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
  <span class="k">yield</span>
<span class="c1"># ...</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="k">raise</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Shutdown</span> <span class="k">if</span> <span class="n">exception_caused_by_shutdown?</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span> <span class="o">==</span> <span class="kp">nil</span>
    <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">get_sidekiq_options</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">raise</span> <span class="n">e</span> <span class="k">unless</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span>
  <span class="n">attempt_retry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">Skip</span>
<span class="k">end</span>
</code></pre>
</div>

<p>如果我们在定义 <code class="highlighter-rouge">Worker</code> 时就禁用了重试，那么在这里就会直接抛出上层的异常，否则就会进入 <code class="highlighter-rouge">#attempt_retry</code> 方法安排任务进行重试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">attempt_retry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
  <span class="n">max_retry_attempts</span> <span class="o">=</span> <span class="n">retry_attempts_from</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">],</span> <span class="vi">@max_retries</span><span class="p">)</span>

  <span class="n">msg</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">]</span> <span class="o">=</span> <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_queue'</span><span class="p">]</span>
                   <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_queue'</span><span class="p">]</span>
                 <span class="k">else</span>
                   <span class="n">queue</span>
                 <span class="k">end</span>

  <span class="n">count</span> <span class="o">=</span> <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retried_at'</span><span class="p">]</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="k">else</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'failed_at'</span><span class="p">]</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="k">end</span>

  <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">max_retry_attempts</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">delay_for</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
    <span class="n">retry_at</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">+</span> <span class="n">delay</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
      <span class="n">conn</span><span class="p">.</span><span class="nf">zadd</span><span class="p">(</span><span class="s1">'retry'</span><span class="p">,</span> <span class="n">retry_at</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">retries_exhausted</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>在上面其实我们提到过，<code class="highlighter-rouge">Poller</code> 每次会从两个有序集合 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 中查找到时的任务加入到对应的队列中，在 <code class="highlighter-rouge">#attempt_retry</code> 方法中，就可以找到看到 <code class="highlighter-rouge">retry</code> 队列中的元素是如何加入的了。</p>

<p>当任务的重试次数超过了限定的重试次数之后，就会执行 <code class="highlighter-rouge">#retries_exhausted</code> 以及 <code class="highlighter-rouge"># send_to_morgue</code> 这一方法，将任务的负载加入 <code class="highlighter-rouge">DeadSet</code> 对象中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">send_to_morgue</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="n">payload</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="no">DeadSet</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">kill</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>这样整个任务的重试过程就结束了，Sidekiq 使用 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 捕获整个流程中出现的异常，并根据传入的 <code class="highlighter-rouge">retry_count</code> 参数进行重试，调度过程还是非常简洁也非常容易理解的。</p>

<h2 id="section-11">总结</h2>

<p>作为一个 Ruby 社区中广泛被使用的异步任务处理的依赖，它的实现是很简单的并且其源代码非常易于阅读，整体的架构也非常清晰。</p>

<p><img src="http://img.draveness.me/2017-08-28-Middlewares-Client-Redis-Sidekiq-Worker.jpg" alt="Middlewares-Client-Redis-Sidekiq-Worker" /></p>

<p>使用键值的内存数据库 Redis 作为客户端和 Worker 之间的桥梁，Redis 的使用简化了 Sidekiq 的很多逻辑，同时对中间件的支持也使其有着良好的扩展性，不过正其实现简单，所以例如任务取消以及定时任务这种比较常见的功能其本身都没有实现，有的是 Sidekiq 本身设计问题导致的，有的需要另外的插件，不过在绝大多数情况下，Sidekiq 都能完全满足我们的需要，解决绝大多数的问题。</p>

<blockquote>
  <p>Follow: <a href="https://github.com/Draveness">Draveness · GitHub</a></p>
</blockquote>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://github.com/mperham/sidekiq">Sidekiq</a></li>
  <li><a href="https://ruby-china.org/topics/31470">Sidekiq 任务调度流程分析</a></li>
</ul>
